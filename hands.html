<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitMax14 Shape Match - Made using Anthropic Opus 4.5 and around 10 simple prompts.</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00ff;
            --neon-yellow: #fff000;
            --neon-green: #00ff88;
            --neon-orange: #ff6600;
            --neon-red: #ff3366;
            --neon-purple: #aa00ff;
            --neon-blue: #0066ff;
            --dark-bg: #0a0a0f;
            --grid-color: rgba(0, 245, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--dark-bg);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Animated grid background */
        .grid-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px); }
        }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 100;
        }

        /* Title overlay */
        .title-overlay {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 200;
            pointer-events: none;
        }

        h1 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(1rem, 2.5vw, 1.6rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 10px var(--neon-cyan)); }
            to { filter: drop-shadow(0 0 30px var(--neon-magenta)); }
        }

        .subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.4em;
            text-transform: uppercase;
        }

        /* Full screen video container */
        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            z-index: 1;
        }

        video, #hand-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        video {
            opacity: 0.3;
        }

        #hand-canvas {
            z-index: 2;
        }

        /* Shape canvas - for drawing the stretchy shape */
        #shape-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: none;
        }

        /* Finger cursors for each hand */
        .finger-cursor {
            position: fixed;
            width: 45px;
            height: 45px;
            border: 3px solid var(--neon-cyan);
            border-radius: 50%;
            pointer-events: none;
            z-index: 60;
            transition: all 0.05s ease-out;
            box-shadow: 0 0 15px var(--neon-cyan);
            display: none;
        }

        .finger-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        /* Left hand cursor - cyan */
        .finger-cursor.left {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px var(--neon-cyan);
        }

        .finger-cursor.left::after {
            background: var(--neon-cyan);
        }

        .finger-cursor.left::before {
            content: 'L';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        /* Right hand cursor - green */
        .finger-cursor.right {
            border-color: var(--neon-green);
            box-shadow: 0 0 20px var(--neon-green);
        }

        .finger-cursor.right::after {
            background: var(--neon-green);
        }

        .finger-cursor.right::before {
            content: 'R';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }

        .finger-cursor.pinching {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 30px var(--neon-yellow);
            transform: scale(0.8);
        }

        .finger-cursor.pinching::after {
            background: var(--neon-yellow);
            box-shadow: 0 0 20px var(--neon-yellow);
        }

        .finger-cursor.grabbing {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 35px var(--neon-magenta), 0 0 60px var(--neon-magenta);
            transform: scale(1.2);
            animation: grabPulse 0.3s ease-in-out infinite;
        }

        .finger-cursor.grabbing::after {
            background: var(--neon-magenta);
        }

        @keyframes grabPulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.3); }
        }

        /* Game UI - moved to left side */
        .game-panel {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--neon-magenta);
            border-radius: 15px;
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 200;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
        }

        .game-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .game-stat-label {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .game-stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        .game-stat-value.timer {
            color: var(--neon-yellow);
            text-shadow: 0 0 10px var(--neon-yellow);
        }

        .game-stat-value.score {
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }

        .game-stat-value.round-score {
            color: var(--neon-orange);
            text-shadow: 0 0 10px var(--neon-orange);
        }

        /* Accuracy meter */
        .accuracy-bar {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(10, 10, 15, 0.9);
            border: 2px solid var(--neon-cyan);
            border-radius: 10px;
            overflow: hidden;
            z-index: 200;
        }

        .accuracy-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-red), var(--neon-yellow), var(--neon-green));
            width: 0%;
            transition: width 0.3s ease;
        }

        .accuracy-label {
            position: fixed;
            bottom: 145px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: var(--neon-cyan);
            letter-spacing: 0.1em;
            z-index: 200;
        }

        /* Status panel */
        .status-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 12px 25px;
            display: flex;
            gap: 20px;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .status-label {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .status-value {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: var(--neon-cyan);
        }

        .status-value.active {
            color: var(--neon-yellow);
        }

        /* Loading state */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 4px solid transparent;
            border-top-color: var(--neon-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
            position: relative;
        }

        .loader::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 4px solid transparent;
            border-top-color: var(--neon-magenta);
            border-radius: 50%;
            animation: spin 0.5s linear infinite reverse;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            color: var(--neon-cyan);
            letter-spacing: 0.3em;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        /* Game buttons - moved below game panel */
        .btn-container {
            position: fixed;
            top: 380px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
        }

        .game-btn {
            background: rgba(10, 10, 15, 0.9);
            border: 2px solid var(--neon-green);
            border-radius: 8px;
            padding: 12px 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: var(--neon-green);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .game-btn:hover {
            background: var(--neon-green);
            color: var(--dark-bg);
            box-shadow: 0 0 30px var(--neon-green);
        }

        .game-btn.reset {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }

        .game-btn.reset:hover {
            background: var(--neon-magenta);
            color: var(--dark-bg);
            box-shadow: 0 0 30px var(--neon-magenta);
        }

        .game-btn.submit {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        .game-btn.submit:hover {
            background: var(--neon-yellow);
            color: var(--dark-bg);
            box-shadow: 0 0 30px var(--neon-yellow);
        }

        .game-btn.sound {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .game-btn.sound:hover {
            background: var(--neon-cyan);
            color: var(--dark-bg);
            box-shadow: 0 0 30px var(--neon-cyan);
        }

        .game-btn.sound.muted {
            border-color: var(--neon-red);
            color: var(--neon-red);
        }

        /* Instructions */
        .instructions {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            padding: 12px 15px;
            max-width: 250px;
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .instructions h3 {
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            color: var(--neon-cyan);
            margin-bottom: 8px;
            letter-spacing: 0.1em;
        }

        .instructions p {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 6px;
        }

        .instructions .highlight-cyan {
            color: var(--neon-cyan);
            font-weight: 700;
        }

        .instructions .highlight-green {
            color: var(--neon-green);
            font-weight: 700;
        }

        .instructions .highlight-magenta {
            color: var(--neon-magenta);
            font-weight: 700;
        }

        .instructions .highlight-yellow {
            color: var(--neon-yellow);
            font-weight: 700;
        }

        /* Game over screen */
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .game-over-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .game-over-title {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta), var(--neon-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            text-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
        }

        .final-score {
            font-family: 'Orbitron', monospace;
            font-size: 5rem;
            color: var(--neon-green);
            text-shadow: 0 0 50px var(--neon-green);
            margin-bottom: 20px;
        }

        .round-scores {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
        }

        .round-score-item {
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 15px 20px;
            text-align: center;
        }

        .round-score-item .round-num {
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            color: var(--neon-cyan);
            margin-bottom: 5px;
        }

        .round-score-item .round-pts {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: var(--neon-yellow);
        }

        .play-again-btn {
            background: linear-gradient(90deg, var(--neon-magenta), var(--neon-cyan));
            border: none;
            border-radius: 12px;
            padding: 20px 50px;
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        .play-again-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.8);
        }

        /* Round transition */
        .round-transition {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 50px var(--neon-cyan);
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .round-transition.visible {
            opacity: 1;
            animation: roundPulse 0.5s ease-out;
        }

        @keyframes roundPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* Match indicator */
        .match-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            color: var(--neon-green);
            text-shadow: 0 0 30px var(--neon-green);
            z-index: 250;
            opacity: 0;
            pointer-events: none;
        }

        .match-indicator.visible {
            opacity: 1;
            animation: matchPop 1s ease-out forwards;
        }

        @keyframes matchPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    <div class="scanlines"></div>

    <div class="loading-overlay" id="loading">
        <div class="loader"></div>
        <div class="loading-text">INITIALIZING BITMAX14</div>
    </div>

    <div class="title-overlay">
        <h1>BitMax14 Shape Match</h1>
        <p class="subtitle">Match the Target Shape!</p>
    </div>

    <div class="video-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="hand-canvas"></canvas>
    </div>

    <!-- Canvas for the shapes -->
    <canvas id="shape-canvas"></canvas>

    <!-- Finger cursors for each hand -->
    <div class="finger-cursor left" id="finger-cursor-left"></div>
    <div class="finger-cursor right" id="finger-cursor-right"></div>

    <!-- Game UI - moved to left side -->
    <div class="game-panel">
        <div class="game-stat">
            <span class="game-stat-label">Round</span>
            <span class="game-stat-value" id="round-display">1 / 5</span>
        </div>
        <div class="game-stat">
            <span class="game-stat-label">Time</span>
            <span class="game-stat-value timer" id="timer-display">0.0s</span>
        </div>
        <div class="game-stat">
            <span class="game-stat-label">Round Score</span>
            <span class="game-stat-value round-score" id="round-score-display">0</span>
        </div>
        <div class="game-stat">
            <span class="game-stat-label">Total Score</span>
            <span class="game-stat-value score" id="total-score-display">0</span>
        </div>
    </div>

    <div class="accuracy-label">ACCURACY: <span id="accuracy-value">0%</span></div>
    <div class="accuracy-bar">
        <div class="accuracy-fill" id="accuracy-fill"></div>
    </div>

    <div class="btn-container">
        <button class="game-btn" id="start-btn">Start Game</button>
        <button class="game-btn submit" id="submit-btn">Submit Shape</button>
        <button class="game-btn reset" id="reset-btn">Reset Points</button>
        <button class="game-btn sound" id="sound-btn">ðŸ”Š Sound ON</button>
    </div>

    <div class="instructions">
        <h3>// How to Play</h3>
        <p><span class="highlight-cyan">12 points</span> to drag!</p>
        <p><span class="highlight-magenta">Target shape</span> shown in <span class="highlight-magenta">pink outline</span></p>
        <p><span class="highlight-yellow">Pinch</span> to grab &amp; drag points to match!</p>
        <p><span class="highlight-green">MUST reach 95% accuracy!</span></p>
        <p>Below 95% = <span class="highlight-magenta">ZERO points!</span></p>
    </div>

    <div class="status-panel">
        <div class="status-item">
            <span class="status-label">Left Hand</span>
            <span class="status-value" id="left-hand-status">--</span>
        </div>
        <div class="status-item">
            <span class="status-label">Right Hand</span>
            <span class="status-value" id="right-hand-status">--</span>
        </div>
        <div class="status-item">
            <span class="status-label">Mode</span>
            <span class="status-value" id="mode-status">IDLE</span>
        </div>
    </div>

    <!-- Round transition display -->
    <div class="round-transition" id="round-transition">ROUND 1</div>

    <!-- Match indicator -->
    <div class="match-indicator" id="match-indicator">+1000 pts!</div>

    <!-- Game over overlay -->
    <div class="game-over-overlay" id="game-over">
        <div class="game-over-title">GAME COMPLETE!</div>
        <div class="final-score" id="final-score">0</div>
        <div class="round-scores" id="round-scores"></div>
        <button class="play-again-btn" id="play-again-btn">Play Again</button>
    </div>

    <script>
        // ============================================
        // SOUND ENGINE - Web Audio API Synthesizer
        // ============================================
        class SoundEngine {
            constructor() {
                this.audioCtx = null;
                this.masterGain = null;
                this.musicGain = null;
                this.sfxGain = null;
                this.isMuted = false;
                this.isPlaying = false;
                this.musicInterval = null;
                this.beatIndex = 0;
            }

            init() {
                if (this.audioCtx) return;
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master gain
                this.masterGain = this.audioCtx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.audioCtx.destination);

                // Music gain
                this.musicGain = this.audioCtx.createGain();
                this.musicGain.gain.value = 0.3;
                this.musicGain.connect(this.masterGain);

                // SFX gain
                this.sfxGain = this.audioCtx.createGain();
                this.sfxGain.gain.value = 0.6;
                this.sfxGain.connect(this.masterGain);
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : 0.5;
                }
                return this.isMuted;
            }

            // Play a synth note
            playNote(frequency, duration, type = 'sine', gainNode = this.sfxGain, attack = 0.01, decay = 0.1) {
                if (!this.audioCtx || this.isMuted) return;
                
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                
                osc.type = type;
                osc.frequency.value = frequency;
                
                gain.gain.setValueAtTime(0, this.audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.audioCtx.currentTime + attack);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(gainNode);
                
                osc.start();
                osc.stop(this.audioCtx.currentTime + duration);
            }

            // Play chord
            playChord(frequencies, duration, type = 'sine') {
                frequencies.forEach(freq => this.playNote(freq, duration, type, this.musicGain));
            }

            // Sound effects
            playGrab() {
                if (!this.audioCtx) return;
                this.playNote(880, 0.1, 'square');
                setTimeout(() => this.playNote(1100, 0.08, 'square'), 50);
            }

            playRelease() {
                if (!this.audioCtx) return;
                this.playNote(660, 0.1, 'triangle');
            }

            playSubmit() {
                if (!this.audioCtx) return;
                const notes = [523, 659, 784, 1047]; // C E G C
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playNote(freq, 0.3, 'sine'), i * 100);
                });
            }

            playRoundStart() {
                if (!this.audioCtx) return;
                this.playNote(392, 0.15, 'sawtooth'); // G
                setTimeout(() => this.playNote(523, 0.15, 'sawtooth'), 100); // C
                setTimeout(() => this.playNote(659, 0.2, 'sawtooth'), 200); // E
                setTimeout(() => this.playNote(784, 0.4, 'sawtooth'), 300); // G
            }

            playGameOver() {
                if (!this.audioCtx) return;
                // Victory fanfare
                const melody = [
                    { freq: 523, time: 0 },     // C
                    { freq: 659, time: 150 },   // E
                    { freq: 784, time: 300 },   // G
                    { freq: 1047, time: 450 },  // C5
                    { freq: 784, time: 600 },   // G
                    { freq: 1047, time: 750 },  // C5
                ];
                melody.forEach(note => {
                    setTimeout(() => this.playNote(note.freq, 0.3, 'sine'), note.time);
                });
            }

            playTick() {
                if (!this.audioCtx) return;
                this.playNote(1200, 0.03, 'sine');
            }

            playHighAccuracy() {
                if (!this.audioCtx) return;
                this.playNote(1318, 0.15, 'sine'); // E6
                setTimeout(() => this.playNote(1568, 0.2, 'sine'), 80); // G6
            }

            // Background music - synthwave style
            startMusic() {
                if (!this.audioCtx || this.isPlaying) return;
                this.isPlaying = true;
                
                // Synthwave chord progression (Am - F - C - G)
                const chords = [
                    [220, 261.63, 329.63],  // Am (A3, C4, E4)
                    [174.61, 220, 261.63],  // F (F3, A3, C4)
                    [261.63, 329.63, 392],  // C (C4, E4, G4)
                    [196, 246.94, 293.66],  // G (G3, B3, D4)
                ];

                // Bass notes
                const bass = [110, 87.31, 130.81, 98]; // A2, F2, C3, G2

                let chordIndex = 0;
                const bpm = 100;
                const beatLength = 60000 / bpm;

                // Arpeggio pattern
                const playArpeggio = () => {
                    if (!this.isPlaying || this.isMuted) return;
                    
                    const chord = chords[chordIndex];
                    const bassNote = bass[chordIndex];
                    
                    // Play bass
                    this.playNote(bassNote, beatLength * 2 / 1000, 'sawtooth', this.musicGain);
                    
                    // Play arpeggio
                    chord.forEach((note, i) => {
                        setTimeout(() => {
                            if (this.isPlaying && !this.isMuted) {
                                this.playNote(note, 0.2, 'triangle', this.musicGain);
                            }
                        }, i * (beatLength / 4));
                    });
                    
                    // Add high synth lead occasionally
                    if (this.beatIndex % 4 === 0) {
                        this.playNote(chord[2] * 2, 0.4, 'sine', this.musicGain);
                    }
                    
                    this.beatIndex++;
                    chordIndex = (chordIndex + 1) % chords.length;
                };

                playArpeggio();
                this.musicInterval = setInterval(playArpeggio, beatLength * 2);
            }

            stopMusic() {
                this.isPlaying = false;
                if (this.musicInterval) {
                    clearInterval(this.musicInterval);
                    this.musicInterval = null;
                }
            }
        }

        // Initialize sound engine
        const soundEngine = new SoundEngine();

        // ============================================
        // DOM Elements
        // ============================================
        const videoElement = document.getElementById('webcam');
        const handCanvas = document.getElementById('hand-canvas');
        const handCtx = handCanvas.getContext('2d');
        const shapeCanvas = document.getElementById('shape-canvas');
        const shapeCtx = shapeCanvas.getContext('2d');
        const fingerCursorLeft = document.getElementById('finger-cursor-left');
        const fingerCursorRight = document.getElementById('finger-cursor-right');
        const loadingOverlay = document.getElementById('loading');
        const resetBtn = document.getElementById('reset-btn');
        const startBtn = document.getElementById('start-btn');
        const submitBtn = document.getElementById('submit-btn');
        const soundBtn = document.getElementById('sound-btn');
        const playAgainBtn = document.getElementById('play-again-btn');

        const leftHandStatus = document.getElementById('left-hand-status');
        const rightHandStatus = document.getElementById('right-hand-status');
        const modeStatus = document.getElementById('mode-status');

        const roundDisplay = document.getElementById('round-display');
        const timerDisplay = document.getElementById('timer-display');
        const roundScoreDisplay = document.getElementById('round-score-display');
        const totalScoreDisplay = document.getElementById('total-score-display');
        const accuracyFill = document.getElementById('accuracy-fill');
        const accuracyValue = document.getElementById('accuracy-value');
        const roundTransition = document.getElementById('round-transition');
        const matchIndicator = document.getElementById('match-indicator');
        const gameOverOverlay = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');
        const roundScoresEl = document.getElementById('round-scores');

        // Game state
        const TOTAL_ROUNDS = 5;
        const NUM_POINTS = 12;
        const MAX_ROUND_SCORE = 10000;
        const TIME_PENALTY_PER_SECOND = 50;
        const MIN_ACCURACY_THRESHOLD = 0.95; // Below 95% accuracy = 0 points - MUST be precise!
        const ACCURACY_POWER = 3; // Exponential curve for remaining 5%

        let gameState = {
            active: false,
            currentRound: 0,
            totalScore: 0,
            roundScores: [],
            roundStartTime: 0,
            currentTime: 0
        };

        // 12 control points for the shape
        let baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.18; // Player shape size
        let targetBaseSize = Math.min(window.innerWidth, window.innerHeight) * 0.28; // Target shape size (bigger)
        let centerX = window.innerWidth / 2;
        let centerY = window.innerHeight / 2;

        // Generate initial 12 points in a dodecagon pattern
        function generateInitialPoints() {
            const points = [];
            for (let i = 0; i < NUM_POINTS; i++) {
                const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                points.push({
                    x: centerX + Math.cos(angle) * baseSize,
                    y: centerY + Math.sin(angle) * baseSize
                });
            }
            return points;
        }

        let points = generateInitialPoints();
        let targetPoints = generateInitialPoints();
        let smoothPoints = points.map(p => ({ ...p }));

        // Grab radius for each point
        const grabRadius = 60;

        // Hand states
        let leftHand = { detected: false, pinching: false, x: 0, y: 0, grabbedPoint: -1 };
        let rightHand = { detected: false, pinching: false, x: 0, y: 0, grabbedPoint: -1 };
        let prevLeftGrabbed = -1;
        let prevRightGrabbed = -1;

        // Resize canvases
        function resizeCanvases() {
            handCanvas.width = window.innerWidth;
            handCanvas.height = window.innerHeight;
            shapeCanvas.width = window.innerWidth;
            shapeCanvas.height = window.innerHeight;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Generate a random target shape (uses targetBaseSize for bigger target)
        function generateRandomTargetShape() {
            const newTarget = [];
            const shapeType = Math.floor(Math.random() * 5);
            
            switch(shapeType) {
                case 0: // Wobbly circle with random radii
                    for (let i = 0; i < NUM_POINTS; i++) {
                        const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                        const radiusVariation = targetBaseSize * (0.6 + Math.random() * 0.8);
                        newTarget.push({
                            x: centerX + Math.cos(angle) * radiusVariation,
                            y: centerY + Math.sin(angle) * radiusVariation
                        });
                    }
                    break;
                case 1: // Star-like shape
                    for (let i = 0; i < NUM_POINTS; i++) {
                        const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                        const radius = i % 2 === 0 ? targetBaseSize * 1.2 : targetBaseSize * 0.5;
                        newTarget.push({
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        });
                    }
                    break;
                case 2: // Elongated shape
                    for (let i = 0; i < NUM_POINTS; i++) {
                        const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                        const xRadius = targetBaseSize * (0.5 + Math.random() * 0.3);
                        const yRadius = targetBaseSize * (1 + Math.random() * 0.5);
                        newTarget.push({
                            x: centerX + Math.cos(angle) * xRadius,
                            y: centerY + Math.sin(angle) * yRadius
                        });
                    }
                    break;
                case 3: // Asymmetric blob
                    for (let i = 0; i < NUM_POINTS; i++) {
                        const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                        let radius = targetBaseSize;
                        if (i < 3) radius *= 1.3;
                        else if (i >= 6 && i < 9) radius *= 0.6;
                        radius += (Math.random() - 0.5) * targetBaseSize * 0.3;
                        newTarget.push({
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        });
                    }
                    break;
                case 4: // Square-ish with rounded corners
                    const cornerIndices = [0, 3, 6, 9];
                    for (let i = 0; i < NUM_POINTS; i++) {
                        const angle = (i / NUM_POINTS) * Math.PI * 2 - Math.PI / 2;
                        let radius = targetBaseSize;
                        if (cornerIndices.includes(i)) {
                            radius *= 1.4;
                        } else {
                            radius *= 0.8;
                        }
                        newTarget.push({
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        });
                    }
                    break;
            }
            
            return newTarget;
        }

        // Reset player points to initial circle
        function resetPoints() {
            points = generateInitialPoints();
            smoothPoints = points.map(p => ({ ...p }));
        }

        // Calculate accuracy
        function calculateAccuracy() {
            let totalDistance = 0;
            let maxPossibleDistance = 0;
            
            for (let i = 0; i < NUM_POINTS; i++) {
                const dx = smoothPoints[i].x - targetPoints[i].x;
                const dy = smoothPoints[i].y - targetPoints[i].y;
                totalDistance += Math.sqrt(dx * dx + dy * dy);
                maxPossibleDistance += targetBaseSize * 2; // Use target size for accuracy calc
            }
            
            const accuracy = Math.max(0, 1 - (totalDistance / maxPossibleDistance));
            return accuracy;
        }

        // Calculate round score - accuracy is CRITICAL
        // Below 50% accuracy = 0 points
        // Uses exponential curve so low accuracy = very few points
        // Example: 100% acc = 10000, 80% acc = 5120, 60% acc = 2160, 50% acc = 1250, below 50% = 0
        function calculateRoundScore(accuracy, timeElapsed) {
            // No points for sloppy submissions
            if (accuracy < MIN_ACCURACY_THRESHOLD) {
                return 0;
            }
            
            // Exponential accuracy scoring (accuracy^3)
            // This heavily rewards high accuracy and punishes low accuracy
            const accuracyScore = Math.pow(accuracy, ACCURACY_POWER) * MAX_ROUND_SCORE;
            
            // Time bonus instead of penalty - faster = more points, but accuracy is king
            const maxTimeBonus = 2000;
            const timeBonus = Math.max(0, maxTimeBonus - (timeElapsed * TIME_PENALTY_PER_SECOND));
            
            const finalScore = Math.round(accuracyScore + timeBonus);
            return finalScore;
        }

        // Start a new game
        function startGame() {
            soundEngine.init();
            soundEngine.startMusic();
            
            gameState.active = true;
            gameState.currentRound = 1;
            gameState.totalScore = 0;
            gameState.roundScores = [];
            gameOverOverlay.classList.remove('visible');
            startNewRound();
        }

        // Start a new round
        function startNewRound() {
            resetPoints();
            targetPoints = generateRandomTargetShape();
            gameState.roundStartTime = Date.now();
            
            soundEngine.playRoundStart();
            
            roundTransition.textContent = `ROUND ${gameState.currentRound}`;
            roundTransition.classList.add('visible');
            setTimeout(() => {
                roundTransition.classList.remove('visible');
            }, 1500);
            
            updateUI();
        }

        // Submit current shape
        function submitShape() {
            if (!gameState.active) return;
            
            const accuracy = calculateAccuracy();
            const timeElapsed = (Date.now() - gameState.roundStartTime) / 1000;
            const roundScore = calculateRoundScore(accuracy, timeElapsed);
            
            soundEngine.playSubmit();
            
            gameState.roundScores.push(roundScore);
            gameState.totalScore += roundScore;
            
            matchIndicator.textContent = `+${roundScore} pts!`;
            matchIndicator.classList.add('visible');
            setTimeout(() => {
                matchIndicator.classList.remove('visible');
            }, 1500);
            
            if (gameState.currentRound < TOTAL_ROUNDS) {
                gameState.currentRound++;
                setTimeout(() => startNewRound(), 1500);
            } else {
                endGame();
            }
            
            updateUI();
        }

        // End the game
        function endGame() {
            gameState.active = false;
            soundEngine.stopMusic();
            soundEngine.playGameOver();
            
            roundScoresEl.innerHTML = '';
            gameState.roundScores.forEach((score, i) => {
                const item = document.createElement('div');
                item.className = 'round-score-item';
                item.innerHTML = `
                    <div class="round-num">Round ${i + 1}</div>
                    <div class="round-pts">${score}</div>
                `;
                roundScoresEl.appendChild(item);
            });
            
            finalScoreEl.textContent = gameState.totalScore;
            gameOverOverlay.classList.add('visible');
        }

        // Update UI elements
        function updateUI() {
            roundDisplay.textContent = `${gameState.currentRound} / ${TOTAL_ROUNDS}`;
            totalScoreDisplay.textContent = gameState.totalScore;
            
            if (gameState.active) {
                const elapsed = (Date.now() - gameState.roundStartTime) / 1000;
                timerDisplay.textContent = elapsed.toFixed(1) + 's';
                
                const accuracy = calculateAccuracy();
                const currentRoundScore = calculateRoundScore(accuracy, elapsed);
                roundScoreDisplay.textContent = currentRoundScore;
                
                accuracyFill.style.width = (accuracy * 100) + '%';
                accuracyValue.textContent = Math.round(accuracy * 100) + '%';
                
                // Play tick sound for high accuracy
                if (accuracy > 0.85) {
                    soundEngine.playHighAccuracy();
                }
            }
        }

        // Sound button handler
        soundBtn.addEventListener('click', () => {
            soundEngine.init();
            const muted = soundEngine.toggleMute();
            soundBtn.textContent = muted ? 'ðŸ”‡ Sound OFF' : 'ðŸ”Š Sound ON';
            soundBtn.classList.toggle('muted', muted);
        });

        // Event listeners for buttons
        resetBtn.addEventListener('click', resetPoints);
        startBtn.addEventListener('click', startGame);
        submitBtn.addEventListener('click', submitShape);
        playAgainBtn.addEventListener('click', startGame);

        // Distance utility
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // Find nearest point to a position
        function findNearestPoint(x, y, excludePoint = -1) {
            let nearest = -1;
            let minDist = grabRadius;

            for (let i = 0; i < points.length; i++) {
                if (i === excludePoint) continue;
                const dist = getDistance({ x, y }, smoothPoints[i]);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            }
            return nearest;
        }

        // Draw the shapes
        function drawShapes() {
            for (let i = 0; i < points.length; i++) {
                smoothPoints[i].x += (points[i].x - smoothPoints[i].x) * 0.3;
                smoothPoints[i].y += (points[i].y - smoothPoints[i].y) * 0.3;
            }

            shapeCtx.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);

            if (gameState.active) {
                drawTargetShape();
            }

            drawPlayerShape();
            drawControlPoints();

            if (leftHand.grabbedPoint >= 0) {
                drawStretchLine(leftHand.x, leftHand.y, smoothPoints[leftHand.grabbedPoint], '#00f5ff');
            }
            if (rightHand.grabbedPoint >= 0) {
                drawStretchLine(rightHand.x, rightHand.y, smoothPoints[rightHand.grabbedPoint], '#00ff88');
            }
        }

        // Draw the target shape
        function drawTargetShape() {
            shapeCtx.save();
            
            shapeCtx.setLineDash([15, 10]);
            shapeCtx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
            shapeCtx.lineWidth = 4;
            shapeCtx.shadowBlur = 20;
            shapeCtx.shadowColor = '#ff00ff';

            shapeCtx.beginPath();
            for (let i = 0; i <= NUM_POINTS; i++) {
                const curr = targetPoints[i % NUM_POINTS];
                const next = targetPoints[(i + 1) % NUM_POINTS];
                const prev = targetPoints[(i - 1 + NUM_POINTS) % NUM_POINTS];

                if (i === 0) {
                    shapeCtx.moveTo(curr.x, curr.y);
                } else {
                    const cp1x = prev.x + (curr.x - targetPoints[(i - 2 + NUM_POINTS) % NUM_POINTS].x) * 0.2;
                    const cp1y = prev.y + (curr.y - targetPoints[(i - 2 + NUM_POINTS) % NUM_POINTS].y) * 0.2;
                    const cp2x = curr.x - (next.x - prev.x) * 0.2;
                    const cp2y = curr.y - (next.y - prev.y) * 0.2;
                    shapeCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
                }
            }
            shapeCtx.closePath();
            shapeCtx.stroke();

            shapeCtx.setLineDash([]);
            targetPoints.forEach((point, i) => {
                shapeCtx.beginPath();
                shapeCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                shapeCtx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
                shapeCtx.lineWidth = 2;
                shapeCtx.stroke();
            });

            shapeCtx.restore();
        }

        // Draw the player's shape
        function drawPlayerShape() {
            let shapeCenterX = 0, shapeCenterY = 0;
            smoothPoints.forEach(p => {
                shapeCenterX += p.x;
                shapeCenterY += p.y;
            });
            shapeCenterX /= NUM_POINTS;
            shapeCenterY /= NUM_POINTS;

            shapeCtx.save();
            shapeCtx.shadowBlur = 40;
            shapeCtx.shadowColor = '#00f5ff';

            const gradient = shapeCtx.createRadialGradient(
                shapeCenterX, shapeCenterY, 0,
                shapeCenterX, shapeCenterY, baseSize * 1.5
            );
            gradient.addColorStop(0, 'rgba(0, 245, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 100, 200, 0.6)');
            gradient.addColorStop(1, 'rgba(75, 0, 130, 0.4)');

            shapeCtx.beginPath();
            for (let i = 0; i <= NUM_POINTS; i++) {
                const curr = smoothPoints[i % NUM_POINTS];
                const next = smoothPoints[(i + 1) % NUM_POINTS];
                const prev = smoothPoints[(i - 1 + NUM_POINTS) % NUM_POINTS];

                if (i === 0) {
                    shapeCtx.moveTo(curr.x, curr.y);
                } else {
                    const cp1x = prev.x + (curr.x - smoothPoints[(i - 2 + NUM_POINTS) % NUM_POINTS].x) * 0.2;
                    const cp1y = prev.y + (curr.y - smoothPoints[(i - 2 + NUM_POINTS) % NUM_POINTS].y) * 0.2;
                    const cp2x = curr.x - (next.x - prev.x) * 0.2;
                    const cp2y = curr.y - (next.y - prev.y) * 0.2;
                    shapeCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
                }
            }
            shapeCtx.closePath();
            shapeCtx.fillStyle = gradient;
            shapeCtx.fill();

            shapeCtx.strokeStyle = '#00f5ff';
            shapeCtx.lineWidth = 3;
            shapeCtx.stroke();

            shapeCtx.restore();

            shapeCtx.save();
            shapeCtx.globalAlpha = 0.3;
            const innerGradient = shapeCtx.createRadialGradient(
                shapeCenterX - baseSize * 0.15, shapeCenterY - baseSize * 0.15, 0,
                shapeCenterX, shapeCenterY, baseSize * 0.4
            );
            innerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            innerGradient.addColorStop(1, 'rgba(0, 245, 255, 0)');
            shapeCtx.beginPath();
            shapeCtx.arc(shapeCenterX - baseSize * 0.1, shapeCenterY - baseSize * 0.1, baseSize * 0.2, 0, Math.PI * 2);
            shapeCtx.fillStyle = innerGradient;
            shapeCtx.fill();
            shapeCtx.restore();
        }

        // Draw control points
        function drawControlPoints() {
            const pointColors = [
                '#00f5ff', '#00ff88', '#fff000', '#ff6600',
                '#ff00ff', '#aa00ff', '#0066ff', '#ff3366',
                '#00ffcc', '#ffaa00', '#ff0066', '#66ff00'
            ];

            smoothPoints.forEach((point, i) => {
                const isGrabbedLeft = leftHand.grabbedPoint === i;
                const isGrabbedRight = rightHand.grabbedPoint === i;
                const isGrabbed = isGrabbedLeft || isGrabbedRight;

                shapeCtx.save();
                shapeCtx.beginPath();
                shapeCtx.arc(point.x, point.y, grabRadius, 0, Math.PI * 2);
                shapeCtx.strokeStyle = isGrabbed ? 'rgba(255, 0, 255, 0.4)' : 'rgba(255, 255, 255, 0.08)';
                shapeCtx.lineWidth = 1;
                shapeCtx.setLineDash([4, 4]);
                shapeCtx.stroke();
                shapeCtx.restore();

                shapeCtx.save();
                shapeCtx.shadowBlur = isGrabbed ? 25 : 12;
                shapeCtx.shadowColor = pointColors[i];

                shapeCtx.beginPath();
                shapeCtx.arc(point.x, point.y, isGrabbed ? 16 : 12, 0, Math.PI * 2);
                
                if (isGrabbed) {
                    shapeCtx.fillStyle = '#ff00ff';
                    shapeCtx.shadowColor = '#ff00ff';
                } else {
                    shapeCtx.fillStyle = pointColors[i];
                }
                shapeCtx.fill();

                shapeCtx.fillStyle = isGrabbed ? '#fff' : 'rgba(0,0,0,0.8)';
                shapeCtx.font = 'bold 9px Orbitron';
                shapeCtx.textAlign = 'center';
                shapeCtx.textBaseline = 'middle';
                shapeCtx.fillText((i + 1).toString(), point.x, point.y);

                shapeCtx.restore();
            });
        }

        // Draw stretch line
        function drawStretchLine(handX, handY, point, color) {
            shapeCtx.save();
            shapeCtx.beginPath();
            shapeCtx.moveTo(handX, handY);
            shapeCtx.lineTo(point.x, point.y);
            shapeCtx.strokeStyle = color;
            shapeCtx.lineWidth = 2;
            shapeCtx.setLineDash([8, 4]);
            shapeCtx.shadowBlur = 8;
            shapeCtx.shadowColor = color;
            shapeCtx.stroke();
            shapeCtx.restore();
        }

        // Draw hand landmarks
        function drawHandLandmarks(landmarks, handedness) {
            const isLeft = handedness === 'Left';
            const color = isLeft ? 'rgba(0, 245, 255, 0.5)' : 'rgba(0, 255, 136, 0.5)';
            const highlightColor = isLeft ? '#00f5ff' : '#00ff88';

            handCtx.save();
            handCtx.shadowBlur = 10;
            handCtx.shadowColor = highlightColor;

            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],
                [0, 5], [5, 6], [6, 7], [7, 8],
                [0, 9], [9, 10], [10, 11], [11, 12],
                [0, 13], [13, 14], [14, 15], [15, 16],
                [0, 17], [17, 18], [18, 19], [19, 20],
                [5, 9], [9, 13], [13, 17]
            ];

            handCtx.strokeStyle = color;
            handCtx.lineWidth = 2;

            connections.forEach(([i, j]) => {
                const p1 = landmarks[i];
                const p2 = landmarks[j];
                handCtx.beginPath();
                handCtx.moveTo(p1.x * handCanvas.width, p1.y * handCanvas.height);
                handCtx.lineTo(p2.x * handCanvas.width, p2.y * handCanvas.height);
                handCtx.stroke();
            });

            landmarks.forEach((landmark, index) => {
                const x = landmark.x * handCanvas.width;
                const y = landmark.y * handCanvas.height;

                handCtx.beginPath();
                handCtx.arc(x, y, index === 8 || index === 4 ? 7 : 3, 0, 2 * Math.PI);
                if (index === 8) {
                    handCtx.fillStyle = '#ff00ff';
                } else if (index === 4) {
                    handCtx.fillStyle = '#fff000';
                } else {
                    handCtx.fillStyle = highlightColor;
                }
                handCtx.fill();
            });

            handCtx.restore();
        }

        // Process hand tracking results
        function onResults(results) {
            handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

            // Store previous grab states for sound triggers
            prevLeftGrabbed = leftHand.grabbedPoint;
            prevRightGrabbed = rightHand.grabbedPoint;

            leftHand.detected = false;
            rightHand.detected = false;
            leftHand.pinching = false;
            rightHand.pinching = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label === 'Left' ? 'Right' : 'Left';

                    drawHandLandmarks(landmarks, handedness);

                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];

                    const fingerX = (1 - indexTip.x) * handCanvas.width;
                    const fingerY = indexTip.y * handCanvas.height;

                    const pinchDistance = getDistance(
                        { x: indexTip.x * handCanvas.width, y: indexTip.y * handCanvas.height },
                        { x: thumbTip.x * handCanvas.width, y: thumbTip.y * handCanvas.height }
                    );
                    const isPinching = pinchDistance < 50;

                    if (handedness === 'Left') {
                        leftHand.detected = true;
                        leftHand.x = fingerX;
                        leftHand.y = fingerY;
                        leftHand.pinching = isPinching;

                        fingerCursorLeft.style.display = 'block';
                        fingerCursorLeft.style.left = (fingerX - 22) + 'px';
                        fingerCursorLeft.style.top = (fingerY - 22) + 'px';

                        if (isPinching) {
                            if (leftHand.grabbedPoint < 0) {
                                leftHand.grabbedPoint = findNearestPoint(fingerX, fingerY, rightHand.grabbedPoint);
                                // Play grab sound
                                if (leftHand.grabbedPoint >= 0 && prevLeftGrabbed < 0) {
                                    soundEngine.playGrab();
                                }
                            }
                            if (leftHand.grabbedPoint >= 0) {
                                points[leftHand.grabbedPoint].x = fingerX;
                                points[leftHand.grabbedPoint].y = fingerY;
                            }
                        } else {
                            // Play release sound
                            if (leftHand.grabbedPoint >= 0) {
                                soundEngine.playRelease();
                            }
                            leftHand.grabbedPoint = -1;
                        }

                        fingerCursorLeft.classList.toggle('pinching', isPinching && leftHand.grabbedPoint < 0);
                        fingerCursorLeft.classList.toggle('grabbing', leftHand.grabbedPoint >= 0);

                    } else {
                        rightHand.detected = true;
                        rightHand.x = fingerX;
                        rightHand.y = fingerY;
                        rightHand.pinching = isPinching;

                        fingerCursorRight.style.display = 'block';
                        fingerCursorRight.style.left = (fingerX - 22) + 'px';
                        fingerCursorRight.style.top = (fingerY - 22) + 'px';

                        if (isPinching) {
                            if (rightHand.grabbedPoint < 0) {
                                rightHand.grabbedPoint = findNearestPoint(fingerX, fingerY, leftHand.grabbedPoint);
                                // Play grab sound
                                if (rightHand.grabbedPoint >= 0 && prevRightGrabbed < 0) {
                                    soundEngine.playGrab();
                                }
                            }
                            if (rightHand.grabbedPoint >= 0) {
                                points[rightHand.grabbedPoint].x = fingerX;
                                points[rightHand.grabbedPoint].y = fingerY;
                            }
                        } else {
                            // Play release sound
                            if (rightHand.grabbedPoint >= 0) {
                                soundEngine.playRelease();
                            }
                            rightHand.grabbedPoint = -1;
                        }

                        fingerCursorRight.classList.toggle('pinching', isPinching && rightHand.grabbedPoint < 0);
                        fingerCursorRight.classList.toggle('grabbing', rightHand.grabbedPoint >= 0);
                    }
                }
            }

            if (!leftHand.detected) {
                fingerCursorLeft.style.display = 'none';
                if (leftHand.grabbedPoint >= 0) soundEngine.playRelease();
                leftHand.grabbedPoint = -1;
            }
            if (!rightHand.detected) {
                fingerCursorRight.style.display = 'none';
                if (rightHand.grabbedPoint >= 0) soundEngine.playRelease();
                rightHand.grabbedPoint = -1;
            }

            updateHandStatus();
            drawShapes();

            if (gameState.active) {
                updateUI();
            }
        }

        // Update hand status display
        function updateHandStatus() {
            if (leftHand.detected) {
                if (leftHand.grabbedPoint >= 0) {
                    leftHandStatus.textContent = 'GRAB';
                    leftHandStatus.classList.add('active');
                } else if (leftHand.pinching) {
                    leftHandStatus.textContent = 'PINCH';
                    leftHandStatus.classList.remove('active');
                } else {
                    leftHandStatus.textContent = 'READY';
                    leftHandStatus.classList.remove('active');
                }
            } else {
                leftHandStatus.textContent = '--';
                leftHandStatus.classList.remove('active');
            }

            if (rightHand.detected) {
                if (rightHand.grabbedPoint >= 0) {
                    rightHandStatus.textContent = 'GRAB';
                    rightHandStatus.classList.add('active');
                } else if (rightHand.pinching) {
                    rightHandStatus.textContent = 'PINCH';
                    rightHandStatus.classList.remove('active');
                } else {
                    rightHandStatus.textContent = 'READY';
                    rightHandStatus.classList.remove('active');
                }
            } else {
                rightHandStatus.textContent = '--';
                rightHandStatus.classList.remove('active');
            }

            const bothGrabbing = leftHand.grabbedPoint >= 0 && rightHand.grabbedPoint >= 0;
            const oneGrabbing = leftHand.grabbedPoint >= 0 || rightHand.grabbedPoint >= 0;

            if (bothGrabbing) {
                modeStatus.textContent = 'STRETCH!';
                modeStatus.classList.add('active');
            } else if (oneGrabbing) {
                modeStatus.textContent = 'PULL';
                modeStatus.classList.add('active');
            } else {
                modeStatus.textContent = 'IDLE';
                modeStatus.classList.remove('active');
            }
        }

        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Animation loop
        function animate() {
            drawShapes();
            if (gameState.active) {
                updateUI();
            }
            requestAnimationFrame(animate);
        }

        // Initialize Camera
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        camera.start().then(() => {
            setTimeout(() => {
                loadingOverlay.classList.add('hidden');
                animate();
            }, 1500);
        }).catch(err => {
            console.error('Camera error:', err);
            document.querySelector('.loading-text').textContent = 'CAMERA ACCESS DENIED';
        });
    </script>
</body>
</html>
